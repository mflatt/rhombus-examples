#lang rhombus

import:
  d = "disposable.rkt"
  "http.rkt"
  "keyring.rkt"
  rkt = "racket.rkt"
  "url.rkt"

val jobs_url:
  url.string_to_url("https://my-webservice.com")

fun keyring_auth(service_user_lookup, auth_proc):
  fun(a_url, headers, query):
    val (service_name, user_name): service_user_lookup(a_url, headers, query)
    val password: keyring.get_password(service_name, user_name)
    auth_proc(user_name, password)(a_url, headers, query)

val service_auth:
  keyring_auth(fun(u, h, q): values("splunk", "my-username"),
               http.basic_auth)

val http_request:
  rkt.make_keyword_procedure(
    // XXX: in a general case use a rest-arg but there is only one positional
    // argument we care about here.
    fun(kws, kwargs, uri):
      val max_tries: 10
      val pos_args: rkt.list(http.current_session(), uri)
      fun request_retry(tries_left):
        val should_retry:
          if tries_left == 0:
           | fun(exn): #false
           | rkt.is_exn_fail
        rkt.proc_with_handlers(
          should_retry,
          fun(e): request_retry(tries_left - 1),
          fun(): rkt.keyword_apply(http.session_request, kws, kwargs, pos_args))
      d.disposable(
        fun(): request_retry(max_tries),
        http.response_close))

keyring.default_keyring(
  keyring.make_keyring_from_string("keychain://"))

val job_doc:
  d.call_with_disposable(
    http_request(jobs_url,
                 'auth': service_auth),
    http.response_json)
