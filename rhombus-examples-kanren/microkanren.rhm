#lang rhombus

/*
  Î¼Kanren: A Minimal Functional Core for Relational Programming
  http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf

  ported to Rhombus (using more native types)
*/

import:
  // Don't forget rhombus/macro or annotations and stuff fail
  rhombus/macro: no_prefix
  racket/base:
    prefix r
    rename:
      #{hash-ref} ~to hash_ref
      #{pair?}    ~to is_Pair

class Var (i :: Integer)
val is_Var: #{Var?}

annotation.macro 'Subst: '(Map.of(Var, Any))
class State (counter :: Integer, subst :: Subst)

val empty_state :: State: State(0, {})

fun walk(var, subst :: Subst) :: Any:
  val value: r.hash_ref(subst, var, #false)
  cond
  | is_Var(value): walk(value, subst)
  | r.not(value): var
  | ~else: value

fun unify_goal(u, v):
  fun (state :: State):
    val subst: unify(u, v, state.subst)
    if subst
    | [State(state.counter, subst)]
    | []

fun unify(u, v, subst :: Subst):
  val u1: walk(u, subst)
  val v1: walk(v, subst)
  cond
  | is_Var(u1) && is_Var(v1) && u1 === v1: subst
  | is_Var(u1): subst ++ {u1: v1}
  | is_Var(v1): subst ++ {v1: u1}
  | r.is_Pair(u1) && r.is_Pair(v1):
      val s1: unify(r.car(u1), r.car(v1), subst)
      s1 && unify(r.cdr(u1), r.cdr(v1), s1)
  | ~else:
      u1 === v1 && subst
